<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Boids GPGPU WebGL2</title>
  <style>
    html, body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
<canvas id="glCanvas"></canvas>
<script>
const BOID_TEXTURE_SIZE = 128;
const NUM_BOIDS = BOID_TEXTURE_SIZE * BOID_TEXTURE_SIZE;

const canvas = document.getElementById("glCanvas");
const gl = canvas.getContext("webgl2");
if (!gl) throw new Error("WebGL2 non support√©");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Extensions requises
if (!gl.getExtension("EXT_color_buffer_float")) alert("EXT_color_buffer_float manquant");

function createDataTexture(data) {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, BOID_TEXTURE_SIZE, BOID_TEXTURE_SIZE, 0, gl.RGBA, gl.FLOAT, data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  return tex;
}

function randomData() {
  const data = new Float32Array(NUM_BOIDS * 4);
  for (let i = 0; i < NUM_BOIDS; i++) {
    data[i * 4 + 0] = Math.random() * 2 - 1; // x
    data[i * 4 + 1] = Math.random() * 2 - 1; // y
    data[i * 4 + 2] = 0.0;
    data[i * 4 + 3] = 1.0;
  }
  return data;
}

let posA = createDataTexture(randomData());
let posB = createDataTexture(randomData());
let velA = createDataTexture(randomData());
let velB = createDataTexture(randomData());

function createFramebuffer(tex) {
  const fb = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
  return fb;
}
const fbPos = createFramebuffer(posB);
const fbVel = createFramebuffer(velB);

function createShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
  }
  return shader;
}

function createProgram(vertexSrc, fragmentSrc) {
  const vs = createShader(gl.VERTEX_SHADER, vertexSrc);
  const fs = createShader(gl.FRAGMENT_SHADER, fragmentSrc);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  return program;
}

const quadVerts = new Float32Array([
  -1, -1,
   1, -1,
  -1,  1,
   1,  1,
]);

const quadVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);

const updateVS = `#version 300 es
in vec2 aPos;
out vec2 vUV;
void main() {
  vUV = aPos * 0.5 + 0.5;
  gl_Position = vec4(aPos, 0.0, 1.0);
}`;

const updateFS = `#version 300 es
precision highp float;
uniform sampler2D uPosition;
uniform sampler2D uVelocity;
uniform vec2 uTexSize;
in vec2 vUV;
out vec4 fragColor;

void main() {
  vec2 pos = texture(uPosition, vUV).xy;
  vec2 vel = texture(uVelocity, vUV).xy;

  // Simple movement update
  pos += vel;

  // Wrap around
  pos = mod(pos + 1.0, 2.0) - 1.0;

  fragColor = vec4(pos, 0.0, 1.0);
}`;

const drawVS = `#version 300 es
in vec2 aUV;
uniform sampler2D uPosition;
uniform vec2 uTexSize;
void main() {
  vec2 pos = texture(uPosition, aUV).xy;
  gl_Position = vec4(pos, 0.0, 1.0);
  gl_PointSize = 2.0;
}`;

const drawFS = `#version 300 es
precision mediump float;
out vec4 fragColor;
void main() {
  fragColor = vec4(0.0, 1.0, 0.8, 1.0);
}`;

const updateProg = createProgram(updateVS, updateFS);
const drawProg = createProgram(drawVS, drawFS);

const texUVs = new Float32Array(NUM_BOIDS * 2);
for (let i = 0; i < NUM_BOIDS; i++) {
  let x = (i % BOID_TEXTURE_SIZE + 0.5) / BOID_TEXTURE_SIZE;
  let y = (Math.floor(i / BOID_TEXTURE_SIZE) + 0.5) / BOID_TEXTURE_SIZE;
  texUVs.set([x, y], i * 2);
}
const boidVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, boidVBO);
gl.bufferData(gl.ARRAY_BUFFER, texUVs, gl.STATIC_DRAW);

function updateTextures() {
  gl.useProgram(updateProg);

  gl.bindFramebuffer(gl.FRAMEBUFFER, fbPos);
  gl.viewport(0, 0, BOID_TEXTURE_SIZE, BOID_TEXTURE_SIZE);
  gl.bindTexture(gl.TEXTURE_2D, posA);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, posA);
  gl.uniform1i(gl.getUniformLocation(updateProg, "uPosition"), 0);

  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, velA);
  gl.uniform1i(gl.getUniformLocation(updateProg, "uVelocity"), 1);

  const aPos = gl.getAttribLocation(updateProg, "aPos");
  gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

function render() {
  updateTextures();

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.useProgram(drawProg);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, posB);
  gl.uniform1i(gl.getUniformLocation(drawProg, "uPosition"), 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, boidVBO);
  const aUV = gl.getAttribLocation(drawProg, "aUV");
  gl.enableVertexAttribArray(aUV);
  gl.vertexAttribPointer(aUV, 2, gl.FLOAT, false, 0, 0);

  gl.drawArrays(gl.POINTS, 0, NUM_BOIDS);

  // ping-pong swap
  [posA, posB] = [posB, posA];
  fbPos = createFramebuffer(posB);

  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
