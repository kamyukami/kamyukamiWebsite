<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Boids GPGPU WebGL2</title>
  <style>
    html, body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
<canvas id="glCanvas"></canvas>
<script type="module">
import * as twgl from 'https://cdn.skypack.dev/twgl.js';

const canvas = document.getElementById("glCanvas");
const gl = canvas.getContext("webgl2");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

if (!gl.getExtension("EXT_color_buffer_float")) alert("EXT_color_buffer_float manquant");

let mouse = [0, 0];
canvas.addEventListener("mousemove", e => {
  mouse = [(e.clientX / canvas.width) * 2.0 - 1.0, -((e.clientY / canvas.height) * 2.0 - 1.0)];
});

const TEX_SIZE = 128;
const NUM = TEX_SIZE * TEX_SIZE;
const texCoords = new Float32Array(NUM * 2);
for (let i = 0; i < NUM; ++i) {
  texCoords[i * 2 + 0] = (i % TEX_SIZE + 0.5) / TEX_SIZE;
  texCoords[i * 2 + 1] = (Math.floor(i / TEX_SIZE) + 0.5) / TEX_SIZE;
}

const quad = {
  a_position: { numComponents: 2, data: [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1] }
};

const boidBufferInfo = twgl.createBufferInfoFromArrays(gl, {
  a_uv: { numComponents: 2, data: texCoords },
});

function createDataTexture() {
  const data = new Float32Array(NUM * 4);
  for (let i = 0; i < NUM; i++) {
    data[i * 4 + 0] = Math.random() * 2 - 1;
    data[i * 4 + 1] = Math.random() * 2 - 1;
    data[i * 4 + 2] = Math.random() * 0.01;
    data[i * 4 + 3] = Math.random() * 0.01;
  }
  return twgl.createTexture(gl, {
    width: TEX_SIZE,
    height: TEX_SIZE,
    src: data,
    format: gl.RGBA,
    internalFormat: gl.RGBA32F,
    minMag: gl.NEAREST,
    type: gl.FLOAT,
  });
}

const state = {
  posA: createDataTexture(),
  posB: createDataTexture(),
  velA: createDataTexture(),
  velB: createDataTexture(),
};

const fbPos = twgl.createFramebufferInfo(gl, [{ attachment: state.posB }], TEX_SIZE, TEX_SIZE);
const fbVel = twgl.createFramebufferInfo(gl, [{ attachment: state.velB }], TEX_SIZE, TEX_SIZE);

const updateShader = twgl.createProgramInfo(gl, [
  `#version 300 es
   in vec2 a_position;
   out vec2 v_uv;
   void main() {
     v_uv = a_position * 0.5 + 0.5;
     gl_Position = vec4(a_position, 0.0, 1.0);
   }`,
  `#version 300 es
   precision highp float;
   uniform sampler2D u_pos;
   uniform sampler2D u_vel;
   uniform vec2 u_mouse;
   uniform vec2 u_texSize;
   in vec2 v_uv;
   out vec4 outColor;
   void main() {
     float uMaxSpeed = 0.01;
     float uAlign = 0.02;
     float uCohesion = 0.005;
     float uSeparation = 0.03;
     float uMouseForce = 0.003;
     float uMouseRadius = 0.2;

     vec2 pos = texture(u_pos, v_uv).xy;
     vec2 vel = texture(u_vel, v_uv).xy;
     vec2 align = vec2(0), cohesion = vec2(0), separation = vec2(0);
     int count = 0;
     for (int x = -2; x <= 2; ++x) {
       for (int y = -2; y <= 2; ++y) {
         vec2 offset = vec2(float(x), float(y)) / u_texSize;
         vec2 otherPos = texture(u_pos, v_uv + offset).xy;
         vec2 otherVel = texture(u_vel, v_uv + offset).xy;
         float d = distance(pos, otherPos);
         if (d > 0. && d < 0.2) {
           align += otherVel;
           cohesion += otherPos;
           separation += (pos - otherPos) / d;
           count++;
         }
       }
     }
     if (count > 0) {
       align /= float(count);
       cohesion = cohesion / float(count) - pos;
       separation /= float(count);
       vel += align * uAlign + cohesion * uCohesion + separation * uSeparation;
     }
     float dm = distance(pos, u_mouse);
     if (dm < uMouseRadius) vel += normalize(pos - u_mouse) * uMouseForce;
     vel = length(vel) > uMaxSpeed ? normalize(vel) * uMaxSpeed : vel;
     outColor = vec4(vel, 0.0, 1.0);
   }`
]);

const positionShader = twgl.createProgramInfo(gl, [
  `#version 300 es
   in vec2 a_position;
   out vec2 v_uv;
   void main() {
     v_uv = a_position * 0.5 + 0.5;
     gl_Position = vec4(a_position, 0.0, 1.0);
   }`,
  `#version 300 es
   precision highp float;
   uniform sampler2D u_pos;
   uniform sampler2D u_vel;
   in vec2 v_uv;
   out vec4 outColor;
   void main() {
     vec2 pos = texture(u_pos, v_uv).xy;
     vec2 vel = texture(u_vel, v_uv).xy;
     pos += vel;
     pos = mod(pos + 1.0, 2.0) - 1.0;
     outColor = vec4(pos, 0.0, 1.0);
   }`
]);

const drawShader = twgl.createProgramInfo(gl, [
  `#version 300 es
   in vec2 a_uv;
   uniform sampler2D u_pos;
   void main() {
     vec2 pos = texture(u_pos, a_uv).xy;
     gl_Position = vec4(pos, 0.0, 1.0);
     gl_PointSize = 2.0;
   }`,
  `#version 300 es
   precision mediump float;
   out vec4 outColor;
   void main() {
     outColor = vec4(0.1, 1.0, 0.8, 1.0);
   }`
]);

function render() {
  gl.useProgram(updateShader.program);
  twgl.setBuffersAndAttributes(gl, updateShader, twgl.createBufferInfoFromArrays(gl, quad));
  twgl.setUniforms(updateShader, {
    u_pos: state.posA,
    u_vel: state.velA,
    u_texSize: [TEX_SIZE, TEX_SIZE],
    u_mouse: mouse
  });
  twgl.bindFramebufferInfo(gl, fbVel);
  twgl.drawBufferInfo(gl, twgl.createBufferInfoFromArrays(gl, quad), gl.TRIANGLES);

  gl.useProgram(positionShader.program);
  twgl.setBuffersAndAttributes(gl, positionShader, twgl.createBufferInfoFromArrays(gl, quad));
  twgl.setUniforms(positionShader, {
    u_pos: state.posA,
    u_vel: state.velB,
  });
  twgl.bindFramebufferInfo(gl, fbPos);
  twgl.drawBufferInfo(gl, twgl.createBufferInfoFromArrays(gl, quad), gl.TRIANGLES);

  gl.useProgram(drawShader.program);
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT);
  twgl.setBuffersAndAttributes(gl, drawShader, boidBufferInfo);
  twgl.setUniforms(drawShader, { u_pos: state.posB });
  gl.drawArrays(gl.POINTS, 0, NUM);

  [state.posA, state.posB] = [state.posB, state.posA];
  [state.velA, state.velB] = [state.velB, state.velA];

  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
