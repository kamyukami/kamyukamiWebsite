<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Boids GPGPU WebGL2</title>
  <style>
    html, body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; width: 100vw; height: 100vh; }
    #gui {
      position: fixed;
      top: 0;
      right: 0;
      padding: 10px;
      background: rgba(0,0,0,0.6);
      color: white;
      font-family: sans-serif;
      font-size: 12px;
      z-index: 10;
    }
    #gui label {
      display: block;
      margin: 4px 0 2px;
    }
  </style>
</head>
<body>
<canvas id="glCanvas"></canvas>
<div id="gui">
  <label>Max Speed <input id="speed" type="range" min="0.001" max="0.05" step="0.001" value="0.01"></label>
  <label>Align <input id="align" type="range" min="0.0" max="0.1" step="0.001" value="0.02"></label>
  <label>Cohesion <input id="cohesion" type="range" min="0.0" max="0.05" step="0.001" value="0.005"></label>
  <label>Separation <input id="separation" type="range" min="0.0" max="0.1" step="0.001" value="0.03"></label>
  <label>Mouse Repulsion <input id="repulsion" type="range" min="0.0" max="0.01" step="0.0005" value="0.003"></label>
  <label>Mouse Radius <input id="radius" type="range" min="0.05" max="1.0" step="0.01" value="0.2"></label>
</div>
<script type="module">
import * as twgl from 'https://cdn.skypack.dev/twgl.js';

const canvas = document.getElementById("glCanvas");
const gl = canvas.getContext("webgl2");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

if (!gl.getExtension("EXT_color_buffer_float")) alert("EXT_color_buffer_float manquant");

const sliders = ['speed', 'align', 'cohesion', 'separation', 'repulsion', 'radius'];
const params = {};
sliders.forEach(id => {
  params[id] = parseFloat(document.getElementById(id).value);
  document.getElementById(id).addEventListener('input', () => {
    params[id] = parseFloat(document.getElementById(id).value);
  });
});

let mouse = [0, 0];
canvas.addEventListener("mousemove", e => {
  mouse = [(e.clientX / canvas.width) * 2.0 - 1.0, -((e.clientY / canvas.height) * 2.0 - 1.0)];
});

// Constantes
const TEX_SIZE = 128;
const NUM = TEX_SIZE * TEX_SIZE;
const quad = {
  a_position: { numComponents: 2, data: [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1] }
};

const texCoords = new Float32Array(NUM * 2);
for (let i = 0; i < NUM; ++i) {
  texCoords[i * 2 + 0] = (i % TEX_SIZE + 0.5) / TEX_SIZE;
  texCoords[i * 2 + 1] = (Math.floor(i / TEX_SIZE) + 0.5) / TEX_SIZE;
}

const boidBufferInfo = twgl.createBufferInfoFromArrays(gl, {
  a_uv: { numComponents: 2, data: texCoords },
});

function createDataTexture() {
  const data = new Float32Array(NUM * 4);
  for (let i = 0; i < NUM; i++) {
    data[i * 4 + 0] = Math.random() * 2 - 1;
    data[i * 4 + 1] = Math.random() * 2 - 1;
    data[i * 4 + 2] = Math.random() * 0.01;
    data[i * 4 + 3] = Math.random() * 0.01;
  }
  return twgl.createTexture(gl, {
    width: TEX_SIZE,
    height: TEX_SIZE,
    src: data,
    format: gl.RGBA,
    internalFormat: gl.RGBA32F,
    minMag: gl.NEAREST,
    type: gl.FLOAT,
  });
}

const state = {
  posA: createDataTexture(),
  posB: createDataTexture(),
  velA: createDataTexture(),
  velB: createDataTexture(),
};

const fbA = twgl.createFramebufferInfo(gl, [{ attachment: state.posB }], TEX_SIZE, TEX_SIZE);
const fbB = twgl.createFramebufferInfo(gl, [{ attachment: state.velB }], TEX_SIZE, TEX_SIZE);

const updateShader = twgl.createProgramInfo(gl, [
  `#version 300 es
   in vec2 a_position;
   out vec2 v_uv;
   void main() {
     v_uv = a_position * 0.5 + 0.5;
     gl_Position = vec4(a_position, 0.0, 1.0);
   }`,
  `#version 300 es
   precision highp float;
   uniform sampler2D u_pos;
   uniform sampler2D u_vel;
   uniform vec2 u_mouse;
   uniform vec2 u_texSize;
   uniform float uMaxSpeed, uAlign, uCohesion, uSeparation, uMouseForce, uMouseRadius;
   in vec2 v_uv;
   out vec4 outColor;
   void main() {
     vec2 pos = texture(u_pos, v_uv).xy;
     vec2 vel = texture(u_vel, v_uv).xy;
     vec2 align = vec2(0), cohesion = vec2(0), separation = vec2(0);
     int count = 0;
     for (int x = -2; x <= 2; ++x) {
       for (int y = -2; y <= 2; ++y) {
         vec2 offset = vec2(float(x), float(y)) / u_texSize;
         vec2 otherPos = texture(u_pos, v_uv + offset).xy;
         vec2 otherVel = texture(u_vel, v_uv + offset).xy;
         float d = distance(pos, otherPos);
         if (d > 0. && d < 0.2) {
           align += otherVel;
           cohesion += otherPos;
           separation += (pos - otherPos) / d;
           count++;
         }
       }
     }
     if (count > 0) {
       align /= float(count);
       cohesion = cohesion / float(count) - pos;
       separation /= float(count);
       vel += align * uAlign + cohesion * uCohesion + separation * uSeparation;
     }
     float dm = distance(pos, u_mouse);
     if (dm < uMouseRadius) vel += normalize(pos - u_mouse) * uMouseForce;
     vel = length(vel) > uMaxSpeed ? normalize(vel) * uMaxSpeed : vel;
     outColor = vec4(vel, 0.0, 1.0);
   }`
]);

const drawShader = twgl.createProgramInfo(gl, [
  `#version 300 es
   in vec2 a_uv;
   uniform sampler2D u_pos;
   void main() {
     vec2 pos = texture(u_pos, a_uv).xy;
     gl_Position = vec4(pos, 0.0, 1.0);
     gl_PointSize = 2.0;
   }`,
  `#version 300 es
   precision mediump float;
   out vec4 outColor;
   void main() {
     outColor = vec4(0.1, 1.0, 0.8, 1.0);
   }`
]);

function render() {
  // update velocity
  gl.useProgram(updateShader.program);
  twgl.setBuffersAndAttributes(gl, updateShader, twgl.createBufferInfoFromArrays(gl, quad));
  twgl.setUniforms(updateShader, {
    u_pos: state.posA,
    u_vel: state.velA,
    u_texSize: [TEX_SIZE, TEX_SIZE],
    u_mouse: mouse,
    uMaxSpeed: params.speed,
    uAlign: params.align,
    uCohesion: params.cohesion,
    uSeparation: params.separation,
    uMouseForce: params.repulsion,
    uMouseRadius: params.radius,
  });
  twgl.bindFramebufferInfo(gl, fbB);
  twgl.drawBufferInfo(gl, twgl.createBufferInfoFromArrays(gl, quad), gl.TRIANGLES);

  // update position
  twgl.setUniforms(updateShader, {
    u_pos: state.posA,
    u_vel: state.velB,
  });
  twgl.bindFramebufferInfo(gl, fbA);
  twgl.drawBufferInfo(gl, twgl.createBufferInfoFromArrays(gl, quad), gl.TRIANGLES);

  // draw to screen
  twgl.bindFramebufferInfo(gl, null);
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.useProgram(drawShader.program);
  twgl.setBuffersAndAttributes(gl, drawShader, boidBufferInfo);
  twgl.setUniforms(drawShader, { u_pos: state.posB });
  gl.drawArrays(gl.POINTS, 0, NUM);

  // swap
  [state.posA, state.posB] = [state.posB, state.posA];
  [state.velA, state.velB] = [state.velB, state.velA];

  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
