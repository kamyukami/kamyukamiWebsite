<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Boids Stylisés</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      z-index: 0;
    }

    #textOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Arial Black', sans-serif;
      font-size: 72px;
      color: white;
      mix-blend-mode: difference;
      pointer-events: none;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div id="textOverlay">ESSAIM</div>
  <canvas id="boidsCanvas"></canvas>

  <script>
    const canvas = document.getElementById("boidsCanvas");
    const ctx = canvas.getContext("2d");
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    const mouse = { x: width / 2, y: height / 2 };
    window.addEventListener("mousemove", e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });

    window.addEventListener("resize", () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    });

    class Boid {
      constructor() {
        this.position = { x: Math.random() * width, y: Math.random() * height };
        this.velocity = { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 };
        this.acceleration = { x: 0, y: 0 };
        this.maxSpeed = 2;
        this.maxForce = 0.05;
      }

      update() {
        this.velocity.x += this.acceleration.x;
        this.velocity.y += this.acceleration.y;

        // Clamp speed
        const speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
        if (speed > this.maxSpeed) {
          this.velocity.x = (this.velocity.x / speed) * this.maxSpeed;
          this.velocity.y = (this.velocity.y / speed) * this.maxSpeed;
        }

        this.position.x += this.velocity.x;
        this.position.y += this.velocity.y;

        this.acceleration.x = 0;
        this.acceleration.y = 0;

        // Wrap around screen
        if (this.position.x < 0) this.position.x = width;
        if (this.position.y < 0) this.position.y = height;
        if (this.position.x > width) this.position.x = 0;
        if (this.position.y > height) this.position.y = 0;
      }

      applyForce(fx, fy) {
        this.acceleration.x += fx;
        this.acceleration.y += fy;
      }

      interact(boids) {
        let align = { x: 0, y: 0 };
        let cohesion = { x: 0, y: 0 };
        let separation = { x: 0, y: 0 };
        let total = 0;

        for (let other of boids) {
          let dx = other.position.x - this.position.x;
          let dy = other.position.y - this.position.y;
          let d = Math.sqrt(dx * dx + dy * dy);

          if (other !== this && d < 80) {
            // align
            align.x += other.velocity.x;
            align.y += other.velocity.y;

            // cohesion
            cohesion.x += other.position.x;
            cohesion.y += other.position.y;

            // separation
            separation.x -= dx / (d * d);
            separation.y -= dy / (d * d);

            total++;
          }
        }

        if (total > 0) {
          align.x /= total; align.y /= total;
          cohesion.x = cohesion.x / total - this.position.x;
          cohesion.y = cohesion.y / total - this.position.y;

          this.applyForce(align.x * 0.05, align.y * 0.05);
          this.applyForce(cohesion.x * 0.001, cohesion.y * 0.001);
          this.applyForce(separation.x * 0.5, separation.y * 0.5);
        }

        // Souris
        let dx = mouse.x - this.position.x;
        let dy = mouse.y - this.position.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 120) {
          this.applyForce(-dx / dist * 0.5, -dy / dist * 0.5);
        }
      }

      draw() {
        ctx.beginPath();
        ctx.fillStyle = "rgba(100, 255, 200, 0.8)";
        ctx.arc(this.position.x, this.position.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    const boids = [];
    for (let i = 0; i < 120; i++) {
      boids.push(new Boid());
    }

    function animate() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.25)";
      ctx.fillRect(0, 0, width, height);

      const textRect = document.getElementById('textOverlay').getBoundingClientRect();

      for (let b of boids) {
        b.interact(boids);

        // Réaction avec texte (rebond simple)
        if (
          b.position.x > textRect.left &&
          b.position.x < textRect.right &&
          b.position.y > textRect.top &&
          b.position.y < textRect.bottom
        ) {
          b.applyForce((b.velocity.x * -1), (b.velocity.y * -1));
        }

        b.update();
        b.draw();
      }

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
